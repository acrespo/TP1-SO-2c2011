\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage[pdftex,usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\lstset{language=C}
\lstset{showstringspaces=false}
\lstset{basicstyle=\ttfamily,}

\begin{document}


\renewcommand{\lstlistingname}{C\'odigo Fuente}
\lstloadlanguages{Octave} 
\lstdefinelanguage{MyPseudoCode}[]{Octave}{
	deletekeywords={beta,det},
	morekeywords={repmat}
} 
\lstset{
	language=MyPseudoCode,
	stringstyle=\ttfamily,
	showstringspaces = false,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\color{gray},
	keywordstyle=\bfseries,
	numbers=left,
	numberstyle=\ttfamily\footnotesize,
	stepnumber=1,                   
	framexleftmargin=0.20cm,
	numbersep=0.37cm,              
	backgroundcolor=\color{white},
	showspaces=false,
	showtabs=false,
	frame=l,
	tabsize=4,
	captionpos=b,               
	breaklines=true,             
	breakatwhitespace=false,      
	mathescape=true
}
\begin{titlepage}
        \thispagestyle{empty}
        \begin{center}
                \includegraphics{./images/itba.jpg}
                \vfill
                \Huge{Sistemas Operativos}\\
                \vspace{1cm}
                \huge{Trabajo Práctico Especial Nº1}\\
        \end{center}
        \vspace{2cm}
        \large{
                \begin{tabular}{lcrc}
                        \textbf{Alvaro Crespo} & & 50758 & \ \ \texttt{acrespo@alu.itba.edu.ar}\\
                        \textbf{Juan Pablo Civile} & & 50453 & \ \ \texttt{jcivile@alu.itba.edu.ar}\\
                        \textbf{Darío Susnisky} & & 50592 & \ \ \texttt{dsusnisk@alu.itba.edu.ar}\\
                        \\ 
                \end{tabular}
        }
        \vfill
        \flushright{12 de Septiembre del 2011}
\end{titlepage}

\setcounter{page}{1}

\tableofcontents
\newpage
\section{Introducción}
El objetivo de este trabajo es familiarizarse con el uso de sistemas cliente-servidor concurrentes, implementando el servidor mediante la creación de procesos hijos 
utilizando \textit{fork()} y mediante la creación de \textit{threads}. Al mismo tiempo, ejercitar el uso de los distintos tipos de primitivas de sincronización y 
comunicación de procesos (IPC) y manejar con autoridad el \textit{filesystem} de Linux desde el lado usuario.

\newpage
\section{Esquema de la aplicación}
Esquema onda el que hicimos con bruno sobre que cosas son procesos y que son threads, y que cosa se comunica con que. Aunque sea un paint.

A la hora de encarar el problema en cuestión, una de las primeras cosas a plantearse era el diseño de la aplicación. Dada la naturaleza y los objetivos planteados para este
 trabajo práctico, era necesario poder identificar que partes de nuestra simulación iban a ser procesos paralelos y cuales tenía coherencia implementarlas como \textit{threads}.
  En este debate, también fue importante no forzar la separación de procesos cuando el problema no lo requería (por ejemplo que cada avión fuera un proceso independiente no agregaba 
  nada y generaba mucha complejidad, por lo que se optó por implementarlos como \textit{threads}).\\ 

En un primer análisis, identificamos como potenciales procesos paralelos de nuestro programa al control del flujo principal del programa, a los parsers, al mapa, al \textit{output},
 a las aerolineas y
 a los aviones. A continuación se puede ver un esquema de este modelo.\\

\begin{center}
 \includegraphics{./images/Diagrama_simulacion_2.png}
 % Diagrama_simulacion_2.png: 549x382 pixel, 96dpi, 14.52x10.11 cm, bb=0 0 412 286
\end{center}


 Luego de cierto debate, vimos que la relación entre el flujo principal, los parsers, el \textit{output} y el mapa era demasiado fuerte, pues, 
 la combinación de estas tres cosas iban a 
 controlar el flujo de la simulación en sí. Inclusive, estas partes tenian una secuencia bastante marcada. Así, se decidió que estos elementos que originalmente bien podrían haber 
 sido planteado como procesos paralelos, era más intuitivo y coherente escribirlo como uno solo.
 Finalmente, el mapa y el \textit{output} fueron implementados como threads del proceso principal ya que si bien su relación es fuerte, nos resulto coherente
  que ambos puedan estar ejecutandose paralelamente. \\

Por otra parte, la aerolínea y los aviones nos resulto intuitivo implementarlo como un proceso aparte. La siguiente decisión tomada fue que los aviones debian ser \textit{threads}
 de los procesos aerolinea. Pues nos resulto necesario implementarlo de esta manera ya que la relación entre una aerolínea y sus aviones era constante, ya que un avión es parte
  de una aerolínea. Aquí se presente otro esquema del modelo final\\

\begin{center}
 \includegraphics{./images/Diagrama_simulacion_1.png}
 % Diagrama_simulacion_1.png: 566x382 pixel, 96dpi, 14.97x10.11 cm, bb=0 0 424 286
\end{center}


\newpage
\section{Modelo OSI}
Separación en capas. Separación clara de responsabilidades. Mejora en la claridad del código.
Esquema gráfico.

El modelo OSI es un modelo que estandariza la forma de diseñar un programa y como comunicar diferentes programas. El modelo OSI cuenta con 7 capaz aunque dadas las funcionalidades de nuestra aplicación solamente debimos implementar cuatro (e inclusive, dos de las
  mismas están implementadas como una). Esto se debe a que nuestro programa no se comunica con otros programas, reduciendo así las capas del modelo OSI implementadas por nosotros.
  El resto de las capas vienen implementadas por el sistema operativo.\\

El modelo OSI es muy útil ya que permite realizar las diferentes partes de una aplicación por separado sin mezclar información innecesaria y de esta manera las implementaciones 
en cada capa son independientes del resto. Por último, la separación en capaz mejora ampliamente la claridad del código.\\

En nuestro caso, la capa de aplicación es la encargada de realizar el flujo y la lógica de la aplicación en sí. Las capas de presentación y sesión estan implementadas como una sola,
 la capa de Marshalling. Esta empaqueta los datos a transmitir a otro proceso en formatos determinados. 
 Nuestra última capa implementada es la de transporte, que es la que se encarga de utilizar los diferentes tipos de \textit{IPCs} para comunicar procesos.\\

Notesé que es de suma importancia la separación en capas ya que, por ejemplo, gracias a esto fue posible implementar los distintos tipos de \textit{IPCs} sin importar el resto de las implementaciones.\\

En el esquema presentado a continuación se puede observar lo descripto en esta sección. \\

\begin{center}
 \includegraphics[scale=0.6]{./images/modelo-osi_nuestro.png}
 % modelo-osi_nuestro.png: 891x495 pixel, 96dpi, 23.57x13.10 cm, bb=0 0 668 371
\end{center}


\newpage
\section{Interfaz de comunicación(???)}
Presentar las distintas interfaces que tuvimos...
Creo que fueron tres en total... 
Criterios de elección Y de descarte...
CHAMPO esta es TU parte, te llama a gritosss jeje.

\newpage
\section{Problemas encontrados(???)}

Uno de los primeros problemas con los que nos topamos, fue el hecho de que los archivos de configuración de los cuales la aplicación debía levantar la información, tenían un formato
bastante díficil para trabajar con el lenguaje C. Al no contar con una estructura que pueda ir agregando elementos a una colección y cambiando de tamaño dinámicamente, debimos 
implementar nuestra propia estructura, \textit{Vector}. Esto probó ser muy útil más adelante ya que la utilizamos en otros sectores del programa.\\

Otro problema con el formato de los archivos de configuración, fue que los límites de las "iteraciones" se marcaban con líneas en blanco, y al parecer hay problemas al querer leer el 
$\\n$ con $fscanf$. Para lidiar con esta situación, recurrimos a la única solución que encontramos, aunque en términos de código no es muy elegante.\\

Otro problema encontrado, se relaciona con el testeo. Una vez implementadas las 4 implementaciones de la interfaz de IPC, diseñamos un pequeño test inicial, para detectar fallas en una 
etapa temprana. El test no era del todo básico, pero tampoco era muy agresivo. En ese momento, nos concentramos en que las implementaciones efectivamente funcionaran (comunicaran
 procesos). Al no haber hecho un test más exhaustivo, a la hora de testear la aplicación completa como un todo, surguieron algunos pequeños problemas relacionados con la 
 comunicación entre procesos que nuestro test inicial no había logrado detectar.\\

\newpage
\section{Conclusiones}
ACUERDENSE DE COMO NOS LA HIZO COMER ROMANNNNN!!!PONGAMOS ALGO COPADO ACA!!!XD

Queda claro, que el este trabajo podría haberse realizado sin necesidad de recurrir al procesamiento paralelo y a la comunicación entre procesos. Pero al haberlo hecho esto de esta forma,
la experiencia adquirida y el aprendizaje resulta mucho más significativo. Por varias razones,
trabajar con varios procesos corriendo al mismo tiempo, al igual que varios threads.
la comunicación entre estos procesos.
la separación en capas, consecuencia necesaria, que agrega mucha claridad al código y conceptualmente, al diferenciar claramente las responsabilidades.
la familiarización con los estándares POSIX y System V, o el simple de hecho de trabajar contra interfaces predefinidas y respetando un estándar predefinido.


Estaria bueno poder comparar el programa usando los diferentes tipos de ipc

\newpage     
\section{Referencias}

\begin{itemize}
  \item Material provisto por la cátedra.
  \item UNIX system programming. Second Edition. Keith Havilland, Dina Gray, Ben Salama.
  \item http://cplusplus.com/
  \item http://beej.us/guide/bgipc/output/html/multipage/unixsock.html
  \item https://computing.llnl.gov/tutorials/pthreads/
  \item https://computing.llnl.gov/tutorials/parallel\_comp/
  \item http://www.csc.villanova.edu/~mdamian/threads/posixsem.html
  \item http://www.cs.cf.ac.uk/Dave/C/node25.html
  \item http://www.users.pjwstk.edu.pl/~jms/qnx/help/watcom/clibref/mq\_overview.html
  \item http://linux.die.net/man/7/mq\_overview
\end{itemize}
   
\end{document}
